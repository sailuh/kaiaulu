---
title: "Graph GoF Patterns: Identifying Patterns via Graph Methods"
output: 
  html_document:
    toc: true
    number_sections: true
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{Graph GoF Patterns: Identifying Patterns via Graph Methods}
  %\VignetteEncoding{UTF-8}
---

# Introduction

> "The Gang of Four (GoF) Design Patterns, introduced in the book “Design Patterns: Elements of Reusable Object-Oriented Software,” authored by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides, provide a catalog of proven solutions to common design problems in software development. The GoF Design Patterns encourage best practices, code reusability, and the separation of concerns, aiding in the development of robust and scalable applications."
- [GeeksForGeeks](https://www.geeksforgeeks.org/gang-of-four-gof-design-patterns/) (2023)

Analyzing a project to detect if such design patterns exist is difficult, as doing so manually takes time to understand the code base, let alone making a custom code to detect syntax and meta relationships. However, with a GoF module (in particular Tsantalis pattern4.jar) that allows us to find such patterns within compiled Java projects. With all that in mind, the reason why we would want to find such patterns is to find out the frequency and where a design GoF design pattern is used within external Java projects. (For a deeper understanding of design patterns in Java, here is a [Java Design Pattern Repository](https://github.com/iluwatar/java-design-patterns) that showcases some).

In short: this notebook provides a brief introduction to the early version of the **GoF** module , using some parts of the **Text** module to identify some of the GoF Design Patterns in source code.

# Setup

Before we begin, ensure that you download Tsantalis [pattern4.jar](https://users.encs.concordia.ca/~nikolaos/pattern_detection.html) and remember where it is saved. To analyze the data that the pattern4.jar generates, we will be using [srcml](https://www.srcml.org) to query against the bytecode analysis of pattern4.

Preparing the Java project for analysis is also important, but keep in mind: not all projects will generate results (as they might not have implemented GoF design patterns)- especially smaller ones! For this purpose, retrieving the .git of the project you are analyzing and compiling the project to retrieve their .class files is paramount!

## Compiling Java Projects

As a short aside, compilation of Java projects is a complex and varied affair. Some projects specify what compilation software they use, while others do not offer such assistance. However, all Java projects require the [Java SDK](https://www.oracle.com/java/technologies/downloads/) to compile- so ensuring this is on your system is necessary before even attempting to compile. It is recommended to use the latest Long-Term Support JDK version, as most software reliably runs on it.

To give an idea about Java compilation, below is a set of projects that use different compilation methods. We will also link to the software that they use. Determining what you should use depends if the project is configured for a certain software or not already, or even whatever software you are comfortable with using. Most well-developed projects describe the building process using their software of choice in their READMEs. The following list is a subset of the top repositories for Java projects, where the two most popular compilation/building software were the primary methods of compilation: Maven (aka Apache Maven) and Gradle. (Note that the projects below are not recommended for use in this notebook)

- [Spring Cloud Alibaba](https://github.com/alibaba/spring-cloud-alibaba): [Maven (aka Apache Maven)](https://maven.apache.org)
- [FastJSON](https://github.com/alibaba/fastjson): [Maven (aka Apache Maven)](https://maven.apache.org) or [Gradle](https://gradle.org)
- [Mindustry](https://github.com/Anuken/Mindustry): [Gradle](https://gradle.org)

There will be times when projects do not explicitly say how they build, so do keep in mind that you will find some difficulty in analyzing such projects. Despite that, gaining familiarity with compiling with these two command-line tools should allow for the compilation of the majority of Java projects on the market.

After compiling the project, locating the folder where all the .class files were generated during compilation and remembering it is necessary to configure the notebook.

## Notebook Setup and Library Requirements

```{r}
rm(list = ls())
seed <- 1
set.seed(seed)
```


```{r warning=FALSE,message=FALSE}
require(kaiaulu)
require(data.table)
require(yaml)
require(stringi)
require(knitr)
require(reticulate)
require(magrittr)
require(gt)
```


# Project Configuration Files

Analyzing open source projects often requires some manual work on your part to find where the open source project hosts its code base and mailing list. Instead of hard-coding this in Notebooks, we keep this information in a project configuration file, relevantly:

- ../tools.yml: 
  - The file path to your pattern4.jar (located under pattern4)*
  - The file path to the srcml folder you installed (located under srcml)*
- ../conf/junit5.yml: 
  - The file path to the .git of the project repository you are analyzing (located under version_control/log)*
  - The file path to where you wish to store the srcml output of the project (located under tool/srcml/srcml_path)
  - The file path to where you have the class files (located under tool/pattern4/class_folder_path)*
  - The file path to where you wish to store the output of pattern4: an xml file (located under tool/pattern4/output_filepath)
  - Filters to exclude and include files with specific endings (located under filter)

The variables that we are initializing are located in these yml configuration files. Please do note that the variables are strings, and a majority are file paths that point somewhere on your machine. The configuration information that it is recommended you check (and most likely have to change) are denoted with a "*". Locate these variables and change them to the correct filepath as necessary.


```{r}
tool <- parse_config("../tools.yml")
conf <- parse_config("../conf/junit5.yml")
srcml_path <- get_tool_project("srcml", tool)
pattern4_path <- get_tool_project("pattern4", tool)

git_repo_path <- get_git_repo_path(conf)
folder_path <- stri_replace_last(git_repo_path,replacement="",regex=".git")

# Tool Parameters 
srcml_filepath <- get_srcml_filepath(conf)
class_folder_path <- get_pattern4_folder_path(conf)
pattern4_output_filepath <- get_pattern4_filepath(conf)

# Filters
file_extensions <- get_file_extensions(conf)
substring_filepath <- get_substring_filepath(conf)
```


# Obtaining GoF Patterns

This approach uses Tsantali's [pattern4.jar](https://users.encs.concordia.ca/~nikolaos/pattern_detection.html) to identify GoF patterns. Pattern4 expects a folder with .class files. These can be obtained by compiling the project using Maven. The process is not always trivial. Some project configuration files exemplify how they can be obtained. Once the folder with binaries is available, we can use the `write_gof_patterns` to instruct pattern4 to generate its XML output. Then, `parse_gof_patterns` can be used to format it into a table containing all the information. When the output path and associated input path are not specified, the file is saved and read from `/tmp`.

```{r}

gof_patterns <- write_gof_patterns(pattern4_path = pattern4_path,
                                   class_folder_path = class_folder_path)

gof_patterns <- parse_gof_patterns()

```

We can then display the table:

```{r}
gof_patterns %>%
  gt(auto_align = FALSE) %>%
  tab_header(
    title = "GoF Patterns",
    subtitle = glue::glue("Tsantalis' et al. Graph Method") 
  ) %>%
    cols_align(
    align = "left",
    columns = c("pattern_name","role_name","element")
  )
```

Note the patterns identified may contain not only the class name, but also methods and variables that constitute part of the pattern. To subset the table to contain only classes we can do the following:

```{r}
gof_patterns <- subset_gof_class(gof_patterns)
```

And once again inspect the table:

```{r}
gof_patterns %>%
  gt(auto_align = FALSE) %>%
  tab_header(
    title = "GoF Patterns",
    subtitle = glue::glue("Tsantalis' et al. Graph Method") 
  ) %>%
    cols_align(
    align = "left",
    columns = c("pattern_name","role_name","element")
  )
```

Because Pattern4 uses bytecode for analysis, the filepath is not available in the output, but rather the namespace. We can rely on `srcml`, another tool, to provide us with the mapping needed to filepath. 

# Obtaining the Mapping of Namespace to File Paths

To use srcml, we leverage the git path to specify the folder which srcml should execute. The `srcml` library will then generate a single file, saved on `srcml_filepath` that contains all the information of the project.

```{r}
srcml_filepath <- annotate_src_text(srcml_path = srcml_path,
                                     src_folder = folder_path,
                                     srcml_filepath)
```


We can then use `srcml` to query against this generated XML file. Here, our interest is to obtain the namespaces to file path mapping: 

```{r}
query_table <- query_src_text_namespace(srcml_path = srcml_path,
                                     srcml_filepath = srcml_filepath)


head(query_table)  %>%
  gt(auto_align = FALSE) 
```

# File Filtering 

Since we have a table, we can actually use Kaiaulu filter functions to do some pre-processing. For Depends in particular, some files are provided as example. This can be inferred looking through the filepaths above, when observing this filepath:

`/depends/src/test/resources/java-code-examples/`

Note the depends project configuration file accounted for that pattern to be removed: 

```{r}
substring_filepath
```


Should we wish to remove such filepaths, we can do so as follows:

```{r}
nrow(query_table)
```


```{r}
query_table <- query_table  %>%
    filter_by_file_extension(file_extensions,"filepath")  %>%
  filter_by_filepath_substring(substring_filepath,"filepath")
nrow(query_table)
```

We can now combine both tables, such that pattern4 contains the filepaths. It is suggested left joins are also performed to verify for any inconsistencies where filepaths are not available for namespaces. 

```{r}
#gof_patterns <- merge(x=gof_patterns, y=query_table, by.x='element', by.y='namespace',all.x=TRUE)
gof_patterns <- merge(x=gof_patterns, y=query_table, by.x='element', by.y='namespace')

head(gof_patterns)  %>%
  gt(auto_align = FALSE) 
```

# File Participation in GoF Patterns

Note the table generated by pattern4 is long format: If a file participates in multiple pattern instances, then the filepath wiill be repeated multiple times in the table. Generally, we want to look at these tables in wide format, at 1 filepath per row when combining against other metrics. This can be obtained performing a dcast:

```{r}
# This table is in long form, we have to dcast it into wide form.
gof_patterns <- gof_patterns[,.(n_gof_patterns=length(instance_id)),by=c("filepath",
                                                                                           "role_name")]

gof_patterns <- dcast(gof_patterns, filepath ~ ...,value.var = "n_gof_patterns")

setnafill(gof_patterns, 
          cols = colnames(gof_patterns)[2:length(colnames(gof_patterns))], 
          fill = 0)

head(gof_patterns)  %>%
  gt(auto_align = FALSE) 
```

