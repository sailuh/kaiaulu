---
title: "Understand Showcase"
output: 
  html_document:
    toc: true
    number_sections: true
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{Understand Showcase}
  %\VignetteEncoding{UTF-8}
---


# Introduction

Within a project, we might want to see the dependencies of files and classes between themselves respectively. parse_r_dependencies and parse_dependencies uses in-house or Depends software respectively to analyze projects. parse_dependencies only provides file dependencies, while parse_r_dependencies provides file and function dependencies for a set of R files. Having Understand installed, we can analyze projects for both file and class dependencies in multiple languages like Java, PHP, HTML, C/C++, Python, Assembly, Ada, etc.

Here is more information on [Scitool's Understand](https://scitools.com)).

This notebook demonstrates a sample use case of the two functions that generates tables from the dependency data Understand outputs without opening Understand.


# Required libraries

```{r warning = FALSE, message = FALSE}
rm(list = ls())
require(kaiaulu)
require(visNetwork)
require(XML)
require(stringi)
require(igraph)
require(data.table)
```

# Project Configuration File

```{r}
conf <- parse_config("conf/kaiaulu.yml")
keep_dependencies_type <- get_understand_keep_dependencies_type(conf)
project_path <- get_understand_project_path(conf)
understand_folder <- get_understand_output_path(conf)
code_language <- get_understand_code_language(conf)
```

# Parse a sample project folder

For sample purposes, we will use the project from [Houari Zegai's Calculator](https://github.com/HouariZegai/Calculator) saved into a folder called sample_project. This folder contains all the .java files that the project uses and the ones we will be analyzing. The directory where we will build the understand analysis base will be saved in a folder called understand

# Build the Understand project

Before asking for the generation of data or parsing through it, we must first build the Understand project data. Firstly, provide the project_path and the primary project language, which in this case is Java. There is a third parameter named output_dir where the project will be built at, so we will give it understand_folder. After building once, you do not need to call this function again unless you have changed files within the project that would need to be re-analyzed.

Please remember/save where the folder is generated as it is necessary for understand_parse_dependencies.

```{r}
build_understand_project(project_path = project_path, language = code_language, output_dir = understand_folder)
```


# Generate Dependencies Network
## For Files

To generate a list containing the node and edge data.tables containing the file dependencies of the project, we will provide it the file path to the built Understand project folder and the parse_type. In this case, we will tell Understand to build the "file" dependencies for us. Once again, providing understand_folder as the value for understand_dir.

Note the format of the generated data.tables after running the below code.

```{r}
file_dependencies <- parse_understand_dependencies(understand_dir = understand_folder, parse_type = "file")
head(file_dependencies[["node_list"]])
head(file_dependencies[["edge_list"]])
```


## For Classes

Near-identical to parsing for file dependencies, class dependencies only requires us change the parse_type to "class". In the output folder, this .xml will be separate from the one generated for file dependencies: fileDependencies.xml and classDependencies.xml respectively.

The generated data is in the same format, however note the different types of dependency types in the edge_table.

```{r}
class_dependencies <- parse_understand_dependencies(understand_dir = understand_folder, parse_type = "class")
head(class_dependencies[["node_list"]])
head(class_dependencies[["edge_list"]])
```


# Transforming to Network
## For Files

To filter out edges by their dependency_kind and prepare the generated table from understand_parse_dependencies by appending label_from and label_to columns to the edge_table, we can call transform_und_dependencies_to_network. All we need to do is provide the generated data into parsed and the vector containing the filter weights into weight_types.

Some valid weight_types that are included for files are:
- Import
- Call
- Create
- Use
- Type GenericArgument

Apart from having a filtered edge_table, this data can also be used for inputting into graph_from_data_frame and visIgraph to visualize the table as a graph, as shown below where we filter by Call and Type GenericArgument.

```{r}
file_graph <- transform_understand_dependencies_to_network(parsed = file_dependencies, weight_types = c(keep_dependencies_type[2], keep_dependencies_type[5]))
head(file_graph)
project_function_network <- igraph::graph_from_data_frame(d=file_graph[["edge_list"]], 
                      directed = TRUE,
                      vertices = file_graph[["node_list"]])
visIgraph(project_function_network,randomSeed = 1)
```


## For Classes

The same applies to outputting our class_dependencies, but we can visualize what our class dependency data is using the same parameters sans the parsed data table.

```{r}
class_graph <- transform_understand_dependencies_to_network(parsed = class_dependencies, weight_types = c(keep_dependencies_type[2], keep_dependencies_type[5]))
head(class_graph)
project_function_network <- igraph::graph_from_data_frame(d=class_graph[["edge_list"]], 
                      directed = TRUE,
                      vertices = class_graph[["node_list"]])
visIgraph(project_function_network,randomSeed = 1)
```

