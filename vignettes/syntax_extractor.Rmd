---
title: "Syntax Extractor"
output: 
  html_document:
    toc: true
    number_sections: true
vignette: >
  %\VignetteIndexEntry{Kaiaulu Syntax Extractor}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  markdown: 
    wrap: 72
---

```{r eval=FALSE}
rm(list = ls())
seed <- 1
set.seed(seed)

# Load libraries
  require(kaiaulu)
  require(data.table)
  require(yaml)
  require(stringi)
  require(XML)
  require(gt)
```

# Introduction

This notebook explains how to convert source code into a structured XML
format using srcML and extract meaningful syntax from it. Syntax
extraction allows us to selectively pull out code elements like classes,
functions, and comments, which helps in generating structured
representations of a project.

Syntax extraction is important for understanding the semantic
relationships in code. For example, rather than examining the entire
code, we can focus on key components like documentation, function names,
or associated commits and issue discussions, to help us compare and
comprehend the files better. This structured approach aids in deeper
analysis such as semantic similarity or machine learning models applied
to code.

In large projects, representing files through different methods can lead
to varied interpretations of how files are related. For example:

-   Representation A could show all the file content to a machine.
-   Representation B could focus only on the names of classes,
    variables, and documentation, capturing semantic meaning tied to the
    code.
-   Representation C might focus on commits and issues, capturing
    conversations about the file’s development.

If we compare two files using these different representations, the
machine might reach different conclusions. A computer might say the
files are similar if we only consider the issue discussions, but if we
look at the actual code (Representation A), they might be very
different.

In Kaiaulu, we aim to develop multiple representations of the code to
extract its meaning. This notebook explains how to set up and use these
extraction functions with srcML.

# Project Configuration File

To extract useful syntax information from a project, Kaiaulu uses
configuration files that describe where the source code is stored, where
the srcML tool is located, and what parts of the code we want to
analyze.

Kaiaulu's configuration files help store this information to ensure
reproducibility, meaning anyone can rerun the extraction process with
the same input and settings and expect the same results. These files
store input paths, tool configurations, and arguments.

Here’s an example configuration for the Maven project:

```         
# Project Configuration File for Maven Project
project:
  website: https://github.com/apache/maven

filter:
  # File extensions to include in the analysis
  keep_filepaths_ending_with:
    - .java
    - .xml
  # File paths to exclude from the analysis (e.g., test files)
  remove_filepaths_containing:
    - test
    - example

srcml:
  # Path to the srcML tool binary
  srcml_path: /usr/local/bin/srcml
  # Path to the folder containing the source code to analyze
  src_folder: ../../maven/maven-artifact/src/main/java/org/apache/maven/artifact/
  # Path where the annotated XML file will be saved
  srcml_filepath: ../../analysis/maven/srcml_output.xml
```

The path to the srcML binary should be defined in tools.yml:

```         
srcml: /usr/local/bin/srcml
```

### Explanation

-   website: URL to the project repository, helpful for reference or project metadata.
-   keep_filepaths_ending_with: A list of file extensions (e.g., .java, .xml) to include in the analysis. This allows you to limit analysis to certain types of files within the project.
-   remove_filepaths_containing: Keywords in file paths to exclude from the analysis (e.g., test, example). This filters out files not relevant to the primary analysis, such as test or example files.
-   srcml_path: The path to the srcML binary that will be used to generate the XML. Update this path according to your srcML installation.
-   src_folder: The directory containing the source code to analyze, relative to the configuration file location. Ensure this is set to the root directory of your codebase (in this example, Maven’s artifact code).
-   srcml_filepath: The output file path for the XML representation generated by srcML. This path stores the annotated XML, making it available for subsequent XPath queries.

Kaiaulu reads these parameters and uses them to perform syntax extraction 
across different codebases without needing to hard-code paths or settings in the scripts.

Before we can begin extracting syntax from the source code, we need to
set up the appropriate paths and configurations. We do this by
specifying the location of the source code, tools, and the desired
output file for the XML annotations. In this case, we will use the Maven
repository as our example project.

Here’s how you can set up the configuration:

```{r eval=FALSE}
# Load the project configuration
tool <- yaml::read_yaml("../tools.yml")
conf <- yaml::read_yaml("../conf/maven.yml")

# Paths from config
srcml_path <- tool[["srcml"]]
src_folder <- conf[["srcml"]][["src_folder"]]
# srcml_output_path <- conf[["tool"]][["srcml_output_path"]]
srcml_filepath <- conf[["srcml"]][["srcml_filepath"]]


# Filters
file_extensions <- conf[["filter"]][["keep_filepaths_ending_with"]]
exclude_paths <- conf[["filter"]][["remove_filepaths_containing"]]


```

# Running the Syntax Extractor

## How the Syntax Extractor Works

At its core, the syntax extractor relies on
[srcML](https://www.srcml.org/), which is a tool that converts source
code into an XML representation. This XML structure gives us a detailed
breakdown of the code: classes, functions, variables, and comments are
annotated with specific XML tags, allowing us to query and extract what
we need.

In this notebook, we’ll walk through the process of setting up the
syntax extractor, running the extraction process, and then querying the
annotated code for useful information like class names, namespaces, and
documentation.

## Annotating the Source Code

Now that we have our configuration set up, we can generate the annotated
XML from the source code.

The first step in extracting useful information from source code is to
convert it into a structured format. That’s where the
annotate_src_text() function comes in.

This function takes the source code and runs srcML on it to generate an
XML file that contains annotations for all the code elements.

The annotate_src_text() function:

-   Takes in three parameters: the path to srcML, the path to the source
    code folder, and the path where you want to save the annotated XML.
-   Runs the srcML command with these inputs and outputs the XML file.
    Here’s how you might use it:

```{r eval=FALSE}
# Creating annotated XML from source code
annotated_file <- annotate_src_text(
  srcml_path = srcml_path,
  src_folder = src_folder,
  srcml_filepath = srcml_filepath
)
```

This file will be key for all further queries, as it contains the entire
structure of the source code in a machine-readable format.

## Understanding XPath and XPath Queries

XPath is a query language that allows us to navigate XML documents. Since srcML
converts source code into XML, we use XPath to navigate and extract
specific elements from this structured representation. XPath
expressions are essentially paths that describe how to reach specific
parts of the XML tree. We can use XPath expressions to retrieve classes, functions, and comments, all represented as XML tags.

#### Understanding the XML Structure

When srcML annotates source code, it converts elements into an XML structure where code components are encapsulated within tags. For example, comments are enclosed in <comment> tags, classes in <class> tags, functions in <function> tags, and imports in <import> tags. Let’s look at an example from the Maven project:

```{xml eval=FALSE}
<unit>
  <import>import <name><name>org</name><operator>.</operator><name>apache</name><operator>.</operator><name>maven</name><operator>.</operator><name>artifact</name><operator>.</operator><name>resolver</name><operator>.</operator><name>filter</name><operator>.</operator><name>ArtifactFilter</name></name>;</import>
  <comment type="block" format="javadoc">/**
   * Default artifact implementation.
   */</comment>
  <class><specifier>public</specifier> class <name>DefaultArtifact</name> <block>{ ... }</block>
</class>
</unit>
```

In this XML, <import> elements contain imported classes, <comment> tags encapsulate file-level or class-level comments, and <class> defines classes with their attributes like <specifier> (e.g., public) and <name> (e.g., DefaultArtifact). This structure allows us to use XPath to target specific elements.

#### Writing the XPath Query

To extract specific elements from this XML, we can write an XPath query. For example, let’s create a query to extract all class names within the XML structure, as well as the comments that precede them. Here’s how we can structure this query:

```{r eval=FALSE}
# Query to extract class comments and names
xpath_query <- "//src:class[preceding-sibling::src:comment]/preceding-sibling::src:comment | //src:class/src:name"
```

This query combines two expressions:

1. //src:class[preceding-sibling::src:comment]/preceding-sibling::src:comment: Finds all comment nodes that appear directly before a class.
2. //src:class/src:name: Retrieves the name of each class.

Each part targets specific parts of the XML hierarchy, allowing us to gather relevant information about classes and their associated comments.

#### XPath Cheat Sheet

Here are some additional XPath expressions that might come in handy when
querying XML files in Kaiaulu:

-   Selecting all elements of a specific type: //src:class - Selects all
    class elements.

-   Selecting by attribute: //src:function[@name='doSomething'] -
    Selects function elements with the attribute name equal to
    doSomething.

-   Selecting based on hierarchy: /src:package/src:class/src:function -
    Selects all function elements inside class elements, which in turn
    are inside package elements.

-   Selecting text inside an element: //src:class/src:name/text() -
    Retrieves the text value inside the name element of a class.

By understanding these basic XPath expressions, you can create custom
queries to extract any specific part of the code that’s represented in
the XML file.

## Using the Extraction Functions

The following sections demonstrate each extraction function. Each function runs a specific XPath query to retrieve different elements from the XML.

### Extract Classes

Retrieves class names and file paths:

```{r eval=FALSE}
# Extracting class names from the XML
class_names <- query_src_text_class_names(
  srcml_path = srcml_path,
  srcml_filepath = srcml_filepath
)

# Display the result as a table
class_names %>%
  gt()
```

This function uses XPath to retrieve all classes by finding <class> tags. This is useful for understanding the core structure of a codebase by listing the classes.

### Extract Namespaces

Retrieves namespaces (or packages) from the XML, helping organize and locate code sections based on their namespaces:

```{r eval=FALSE}
# Extracting namespaces from the XML
namespaces <- query_src_text_namespace(
  srcml_path = srcml_path,
  srcml_filepath = srcml_filepath
)

# Display the namespaces
namespaces %>%
  gt()
```

The function looks for <package> tags to identify namespaces, which is particularly useful in projects that follow package-based organization.

### Extract File-Level Documentation

Retrieves file-level documentation, optionally excluding license headers:

```{r eval=FALSE}
file_docs <- query_src_text_file_docs(
  srcml_path = srcml_path,
  srcml_filepath = srcml_filepath,
  exclude_license = TRUE
)

# Display the file-level documentation
file_docs %>%
  gt()
```

exclude_license: If TRUE, excludes comments containing license-related keywords. Defaults to TRUE.

Useful for summarizing file-level comments or introductory documentation without including boilerplate license headers.

Optional step: From the generated output table, we are able to use regular expressions
to alter the output with the stringi library. For example, the output
contains empty comments /\*\* \*/. We can remove these and get the table
with empty comments filtered out:

```{r eval=FALSE}
dt_file_docs <- file_docs

# Define a function to check if a comment is empty
is_comment_empty <- function(comment_text) {
  # Remove comment markers and asterisks
  cleaned_text <- stri_replace_all_regex(
    comment_text,
    pattern = "/\\*\\*?|\\*/|\\*",
    replacement = ""
  )
  # Trim whitespaces
  cleaned_text <- stri_trim_both(cleaned_text)
  # Check if the cleaned text is empty
  return(nchar(cleaned_text) == 0)
}

# Create a vector indicating which comments are empty
empty_comments <- sapply(dt_file_docs$file_docs, is_comment_empty)

# Filter out the empty comments
dt_file_docs <- dt_file_docs[!empty_comments, ]

# Display the filtered data
dt_file_docs %>%
  gt()
```

Another example is removing the comment delimiters, leaving just the
plain text:

```{r eval=FALSE}
# Define a function to clean the comment text
clean_comment <- function(comment_text) {
  # Remove the starting /** and ending */
  comment_text <- stri_replace_all_regex(
    comment_text,
    pattern = "^/\\*\\*?|\\*/$",
    replacement = ""
  )
  # Split the comment into lines
  comment_lines <- unlist(stri_split_lines(comment_text))
  # Remove leading * and whitespace from each line
  comment_lines <- stri_replace_all_regex(
    comment_lines,
    pattern = "^\\s*\\*\\s?",
    replacement = ""
  )
  # Combine the lines back into a single string
  cleaned_text <- stri_trim_both(paste(comment_lines, collapse = "\n"))
  return(cleaned_text)
}

# Apply the cleaning function to the 'file_docs' column
dt_file_docs[, file_docs := sapply(file_docs, clean_comment)]

# Display the cleaned data
dt_file_docs %>%
  gt()
```

### Extract Class-Level Documentation

Retrieves documentation comments directly preceding class definitions:

```{r eval=FALSE}
class_docs <- query_src_text_class_docs(
  srcml_path = srcml_path,
  srcml_filepath = srcml_filepath,
  exclude_license = TRUE
)

# Display the class-level documentation
class_docs %>%
  gt()
```

exclude_license: If TRUE, excludes comments containing license-related keywords. Defaults to TRUE.

Class-specific documentation is useful for providing insight into the purpose or functionality of each class.

### Extract Variables

Retrieves variables, optionally including variable types:

```{r eval=FALSE}
# Extract variables with types
variables_with_types <- query_src_text_variables(
  srcml_path = srcml_path,
  srcml_filepath = srcml_filepath,
  var_type = TRUE
)

# Display the result
variables_with_types %>%
  gt()
```

var_type: If TRUE, includes variable types alongside names. Defaults to TRUE.

Retrieves variable names, and optionally types, which can be helpful for analyzing data structures or variable usage patterns in the code.

### Extract Functions

Retrieves function names and optionally includes parameters:

```{r eval=FALSE}
# Extract functions with parameters
functions_with_params <- query_src_text_functions(
  srcml_path = srcml_path,
  srcml_filepath = srcml_filepath,
  include_parameters = TRUE
)

# Display the result
functions_with_params %>%
  gt()

```

include_parameters: If TRUE, includes function parameters in the output. Defaults to TRUE.

Useful for identifying function definitions and their expected inputs, helping with code comprehension and documentation.

### Extract Imports

Extracts all import statements, indicating dependencies or external packages used by the project:

```{r eval=FALSE}
# Extract functions without parameters
imports <- query_src_text_imports(
  srcml_path = srcml_path,
  srcml_filepath = srcml_filepath
)

# Display the result
imports %>%
  gt()
```

Lists all imported libraries or packages, showing a clear view of dependencies or third-party tools integrated into the codebase.

### Extract Packages

Retrieves package names and their associated file paths:

```{r eval=FALSE}
  
packages <- query_src_text_packages(
  srcml_path = srcml_path,
  srcml_filepath = srcml_filepath
)

# Display the result
packages %>%
  gt()  
```

Shows the package structure, which aids with understanding how code is modularized or grouped in the project.

### Combined Queries

You can combine queries, such as file and class-level documentation, into one table for easier comparison:

```{r eval=FALSE}
# Extract file-level comments
file_docs <- query_src_text_file_docs(
  srcml_path = srcml_path,
  srcml_filepath = srcml_filepath
)

# Extract class-level comments
class_docs <- query_src_text_class_docs(
  srcml_path = srcml_path,
  srcml_filepath = srcml_filepath
)

# Join the two tables by filepath
comments_combined <- merge(
  file_docs, 
  class_docs, 
  by = "filepath", 
  all = TRUE  # Keep all files, even if only file-level or class-level comments exist
)

# Display the combined table with gt for better formatting
comments_combined %>%
  gt()
```
